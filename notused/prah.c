//------------------------------------------------------------------------------- // //    File: //        prah.c // #include "PIDefines.h" #ifdef __PIMWCWMacPPC__     #include "prah-PPC.ch" #elif defined(__PIMWCWMac68K__)     #include "prah-68k.ch"     // We're using Metrowerks and they have an A4 library, so set that up:     #include <SetupA4.h>     #include <A4Stuff.h>         #define UseA4 // We've now defined this for quick checks later. #else     #include "prah.h" #endif #include <math.h> #include <stdio.h> #include <stdlib.h> #include <math.h> // Peker til tabellen //prcomplex *sincos_tab; //------------------------------------------------------------------------------- //    Prototypes. //------------------------------------------------------------------------------- // Everything comes in and out of ENTRYPOINT. It must be first routine in source: MACPASCAL void ENTRYPOINT (const short selector,                         FilterRecord *filterParamBlock,                         long *data,                         short *result); void InitGlobals (Ptr globalPtr);             // Initialize globals. void ValidateParameters (GPtr globals);        // Validates (inits) parameters. void DoStart (GPtr globals);                 // Main routine. void DoParameters (GPtr globals); void DoPrepare (GPtr globals); void DoContinue (GPtr globals); void DoFinish (GPtr globals); void StartWithAdvanceState (GPtr globals); void prah (GPtr globals, const Boolean doProgress); void CalcProxyScaleFactor (Rect proxyScaleRect, Rect *proxyRect, short *scaleFactor); boolean ParametersTest(GPtr globals); void ZoomInRect (GPtr globals, Boolean mask); void ZoomOutRect (GPtr globals, Boolean mask); void StartNoAdvanceState (GPtr globals); void DoInitialRect (GPtr globals); Boolean DoNextRect (GPtr globals); //void Ret(GPtr globals); void BuildProxy (GPtr globals); void scaleRect(Rect *l, short n, short d); void shrinkRect(Rect *l, short x, short y); void copyRect(Rect *l, const Rect *r);                 //------------------------------------------------------------------------------- //    Globals -- Define global variables for plug-in scope. //------------------------------------------------------------------------------- // Windows global for plug-in (considered a Dynamically Linked Library). // Leave NULL for Macintosh; many cross-platform library utilities require // something passed in for hDllInstance: Handle hDllInstance = NULL; //------------------------------------------------------------------------------- //    ENTRYPOINT Export -- Export our entrypoint // //    Have to export our info for PPCGlue stub which needs a descriptor built //    to be called from within a 68k code fragment. //------------------------------------------------------------------------------- #ifdef __PIMacPPC__                         // For "fat" PowerMac plug-ins     enum     {         uppEntryProcInfo = kPascalStackBased             | RESULT_SIZE(0)             | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(short)))             | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(FilterRecord *)))             | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(long *)))             | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(short *)))     };     #if PRAGMA_EXPORT_SUPPORTED         #pragma export on     #endif     RoutineDescriptor main_PPC = BUILD_ROUTINE_DESCRIPTOR(uppEntryProcInfo, main);     #if PRAGMA_EXPORT_SUPPORTED         #pragma export reset     #endif #endif //------------------------------------------------------------------------------- // //    ENTRYPOINT / main // //    All calls to the plug-in module come through this routine. //    It must be placed first in the resource. To achieve this, //    most development systems require this be the first routine //    in the source. // //    The entrypoint will be "pascal void" for Macintosh, //    "void" for Windows. // //    Inputs: //        const short selector                         Host provides selector indicating //                                                     what command to do. // //        FilterRecord *filterParamBlock                 Host provides pointer to parameter //                                                     block containing pertinent data //                                                     and callbacks from the host. //                                                     See PIFilter.h. // //    Outputs: //        FilterRecord *filterParamBlock                 Host provides pointer to parameter //                                                     block containing pertinent data //                                                     and callbacks from the host. //                                                     See PIFilter.h. // //        long *data                                     Use this to store a handle to our //                                                     global parameters structure, which //                                                     is maintained by the host between //                                                     calls to the plug-in. // //        short *result                                 Return error result or noErr. Some //                                                     errors are handled by the host, some //                                                     are silent, and some you must handle. //                                                     See PIGeneral.h. // //------------------------------------------------------------------------------- MACPASCAL void ENTRYPOINT (const short selector,                         FilterRecord *filterParamBlock,                         long *data,                         short *result) {    //---------------------------------------------------------------------------     //    (1) Enter code resource if Mac 68k.     //---------------------------------------------------------------------------         #ifdef UseA4                 // Are we in 68k Mac MW?         EnterCodeResource();     // A4-globals     #endif         //---------------------------------------------------------------------------     //    (2) Check for about box request.     //     //     The about box is a special request; the parameter block is not filled     //     out, none of the callbacks or standard data is available. Instead,     //     the parameter block points to an AboutRecord, which is used     //     on Windows.     //---------------------------------------------------------------------------     if (selector == filterSelectorAbout)     {         DoAbout((AboutRecordPtr)filterParamBlock);     }     else     { // do the rest of the process as normal:         //-----------------------------------------------------------------------         //    (3) Initialize function and global pointers.         //         //     Initialize function pointer routine dispatcher. We use this to jump         //     to the different routines, instead of a long obnoxious switch         //     statement. All routines are expected to have the same prototype         //     of "void RoutineName (globals)". Returns any errors in gResult.         //         //     WARNING: These better be in the order of the selector AND there         //     better be a routine for every selector call.         //-----------------------------------------------------------------------                 static const FProc routineForSelector [] =         {             /* filterSelectorAbout              DoAbout, */             /* filterSelectorParameters */    DoParameters,             /* filterSelectorPrepare */        DoPrepare,             /* filterSelectorStart */        DoStart,             /* filterSelectorContinue */    DoContinue,             /* filterSelectorFinish */        DoFinish         };                 Ptr globalPtr = NULL;         // Pointer for global structure         GPtr globals = NULL;          // actual globals         //-----------------------------------------------------------------------         //    (4) Allocate and initalize globals.         //         //     AllocateGlobals requires the pointer to result, the pointer to the         //     parameter block, a pointer to the handle procs, the size of our local         //     "Globals" structure, a pointer to the long *data, a Function         //     Proc (FProc) to the InitGlobals routine. It automatically sets-up,         //     initializes the globals (if necessary), results result to 0, and         //     returns with a valid pointer to the locked globals handle or NULL.         //-----------------------------------------------------------------------                 globalPtr = AllocateGlobals ((uint32)result,                                     (uint32)filterParamBlock,                                     filterParamBlock->handleProcs,                                     sizeof(Globals),                                     data,                                     InitGlobals);                 if (globalPtr == NULL)         { // Something bad happened if we couldn't allocate our pointer.         // Fortunately, everything's already been cleaned up,         // so all we have to do is report an error.                 *result = memFullErr;         return;         }                 // Get our "globals" variable assigned as a Global Pointer struct with the         // data we've returned:         globals = (GPtr)globalPtr;         //-----------------------------------------------------------------------         //    (5) Dispatch selector.         //-----------------------------------------------------------------------         if (selector > filterSelectorAbout && selector <= filterSelectorFinish)             (routineForSelector[selector-1])(globals); // dispatch using jump table         else             gResult = filterBadParameters;                     //-----------------------------------------------------------------------         //    (6) Unlock data, and exit resource.         //         //    Result is automatically returned in *result, which is         //    pointed to by gResult.         //-----------------------------------------------------------------------                     // unlock handle pointing to parameter block and data so it can move         // if memory gets shuffled:         if ((Handle)*data != NULL)             PIUnlockHandle((Handle)*data);         } // about selector special                #ifdef UseA4             // Are we in 68k Mac MW?         ExitCodeResource(); // A4-globals     #endif     } // end ENTRYPOINT //------------------------------------------------------------------------------- // //    InitGlobals //    //    Initalize any global values here. Called only once when global //    space is reserved for the first time. // //    Inputs: //        Ptr globalPtr         Standard pointer to a global structure. // //    Outputs: //        Initializes any global values with their defaults. // //------------------------------------------------------------------------------- void InitGlobals (Ptr globalPtr) {        // create "globals" as a our struct global pointer so that any     // macros work:     GPtr globals = (GPtr)globalPtr;         // Initialize global variables:     ValidateParameters (globals);     } // end InitGlobals //------------------------------------------------------------------------------- // //    ValidateParameters // //    Initialize parameters to default values. // //    Inputs: //        GPtr globals         Pointer to global structure. // //------------------------------------------------------------------------------- void ValidateParameters (GPtr globals) {    if (gStuff->parameters == NULL)     { // We haven't created these yet.         gStuff->parameters = PINewHandle ((long) sizeof (TParameters));         if (gStuff->parameters != NULL)         { // Got it. Fill out the fields.                 gKanal1=128;             gKanal2=128;             gKanal3=128;             gKanal4=128;                                 gUseAdvance = false;             gZoomFactor=6;                     gHostIsPremiereWin = IsWindows(HostIsPremiere());         }         else         { // Oops. Couldn't allocate memory.                             gResult = memFullErr;             return;         }     } // parameters     } // end ValidateParameters /*****************************************************************************/ /* Inicializace vstupních parametr? filtru - neprob?hne p?i volání "Poslední Filtr"*/ void DoParameters (GPtr globals) {        ValidateParameters (globals);     if (gStuff->parameters != NULL)     {     }     gQueryForParameters = TRUE; }/*****************************************************************************/ /* V?po?et pot?ebné pam?ti pro funkci filtru */ void DoPrepare (GPtr globals) {    short     rowWidth = 0;     short     total = 0;     long    oneRow = 0;     long    inOutRow = 0;     long    inOutAndMask = 0;         gStuff->bufferSpace = 0;        ValidateParameters (globals);     total = gStuff->imageSize.v;     rowWidth = gStuff->imageSize.h;        oneRow = rowWidth * (gStuff->planes);     inOutRow = oneRow * 2;     inOutAndMask = inOutRow + rowWidth;     while (((inOutAndMask * gRowSkip) < (gStuff->maxSpace-gStuff->bufferSpace)) && (gRowSkip < total)) gRowSkip++;     gStuff->maxSpace = gRowSkip * inOutAndMask + gStuff->bufferSpace;     }/*****************************************************************************/ /* Zobrazení UI a za?átek filtrace */ void DoStart (GPtr globals) {        Rect    imageRect;         return;     ValidateParameters (globals); // Pokud nejsou inicializovány parametry filtru, tak je inicializuje     // lze pou?ít Advance ?     gUseAdvance = AdvanceStateAvailable () &&                 DisplayPixelsAvailable () &&                 !gHostIsPremiereWin;                                             // Adobe Premiere for Windows doesn't do AdvanceState right     ReadScriptParams (globals);                 // P?e?te p?edchozí nastavení filtru     if (gQueryForParameters)     {         DoUI (globals);                         // Zobrazí UI         gQueryForParameters = FALSE;     }     else     {         imageRect.top = 0;//pokud je filtr vyvolán bez UI - inicializace rozmeru I/O oblastí         imageRect.left = 0;         imageRect.bottom = gStuff->imageSize.v;         imageRect.right = gStuff->imageSize.h;         copyRect(&gStuff->filterRect, &imageRect);         copyRect(&gStuff->inRect, &imageRect);                gStuff->inLoPlane = gStuff->outLoPlane = 0;         gStuff->inHiPlane = gStuff->outHiPlane = gStuff->planes - 1;         copyRect(&gStuff->maskRect, &gStuff->filterRect);         gStuff->inputRate = long2fixed(1L);         gStuff->maskRate = gStuff->inputRate;         gStuff->inputPadding = plugInWantsEdgeReplication;         gStuff->outputPadding = gStuff->inputPadding;         gStuff->maskPadding = gStuff->inputPadding;             gResult = AdvanceState ();         DoZoomRect (globals,false); //        Ret(globals);             }     if (gResult != noErr) return;         if (gUseAdvance) StartWithAdvanceState(globals); }    /*****************************************************************************/ /* Pokra?ování filtrace - pokud se filtruje po ?ástech - not Advance */ void DoContinue (GPtr globals) {    if (TestAbort () || gResult != noErr)     {         gResult = userCanceledErr;         return;     }     if (!gUseAdvance)     {         Prah(globals,true);         if (!DoNextRect (globals))             {                 PISetRect (&gStuff->inRect, 0, 0, 0, 0);                 PISetRect (&gStuff->outRect, 0, 0, 0, 0);                 PISetRect (&gStuff->maskRect, 0, 0, 0, 0);             }     }     else     {         PISetRect (&gStuff->inRect, 0, 0, 0, 0);         PISetRect (&gStuff->outRect, 0, 0, 0, 0);         PISetRect (&gStuff->maskRect, 0, 0, 0, 0);     } }/*****************************************************************************/ /* Úklid po filtru a zápis nastavení parametr? filtru */ void DoFinish (GPtr globals) {    WriteScriptParams (globals); }/*****************************************************************************/ /* Filtrace celeho obrazu najednou */ void StartWithAdvanceState (GPtr globals) {    int16 row;     int32 total;     total = gStuff->filterRect.bottom - gStuff->filterRect.top;     gStuff->inLoPlane = gStuff->outLoPlane = 0;     gStuff->inHiPlane = gStuff->outHiPlane = gStuff->planes - 1;         /* Pokud chceme pou?ít kanály*/     #if useAlpha     if (!gStuff->isFloating)     {         gStuff->wantsAbsolute = true;                 if (gStuff->inLayerPlanes !=0 && gStuff->inTransparencyMask != 0)             gStuff->inHiPlane = gStuff->absLayerPlanes - 1 +                                 gStuff->absTransparencyMask +                                 gStuff->absLayerMasks +                                 gStuff->absInvertedLayerMasks +                                 gStuff->absNonLayerPlanes;                 if (gStuff->outLayerPlanes !=0 && gStuff->outTransparencyMask !=0)             gStuff->outHiPlane = gStuff->outLayerPlanes - 1 +                                 gStuff->outTransparencyMask +                                 gStuff->outLayerMasks +                                 gStuff->outInvertedLayerMasks +                                 gStuff->outNonLayerPlanes;     }     #endif     gStuff->inRect.left = gStuff->outRect.left = gStuff->maskRect.left = gStuff->filterRect.left = 0;     gStuff->inRect.right = gStuff->outRect.right = gStuff->maskRect.right = gStuff->filterRect.right = gStuff->imageSize.h;     gStuff->inputRate = long2fixed (1L);     gStuff->maskRate = long2fixed (1L);     for (row = 0; row < gStuff->imageSize.v; row += gRowSkip)     {         if (TestAbort () || gResult != noErr)         {             gResult = userCanceledErr;             goto done;         }         gStuff->inRect.top = gStuff->outRect.top = gStuff->maskRect.top = gStuff->filterRect.top=row;         gStuff->inRect.bottom = gStuff->outRect.bottom = gStuff->maskRect.bottom = gStuff->filterRect.bottom=row + gRowSkip;         gResult = AdvanceState ();            if (gResult != noErr)             goto done;                 Prah (globals, true);         } done:     PISetRect (&gStuff->inRect, 0, 0, 0, 0);     PISetRect (&gStuff->outRect, 0, 0, 0, 0);     PISetRect (&gStuff->maskRect, 0, 0, 0, 0); }/******************************************************/ /* provedení filtrace             */ void Prah(GPtr globals, Boolean doProgress ) {    short i, j;     int plane;     int prah[4];     const short total = gStuff->filterRect.bottom - gStuff->filterRect.top;    //celkov? pocet v?stupního ?ádk?     const short outColumns= gStuff->outRect.right - gStuff->outRect.left; //pocet sloupc? v?stupního obrázku     const short outRows = gStuff->outRect.bottom - gStuff->outRect.top;    // pocet ?ádk? v?stupního obrázku     const short outPlanes = gStuff->outHiPlane - gStuff->outLoPlane + 1; //pocet kanál? v?stupního obrázku     const short inColumns = gStuff->imageSize.h;                             //pocet sloupc? vstupniho obrázku     const short inRows = gStuff->imageSize.v;                         //pocet ?ádk? vstupniho obrázku     const short inPlanes = gStuff->inHiPlane - gStuff->inLoPlane + 1;         //pocet kanál? vstupniho obrázku     unsigned8 *srcPtr = (unsigned8 *) gStuff->inData;    //ukazatel na vstupní obrázek     unsigned8 *dstPtr = (unsigned8 *) gStuff->outData;     //ukazatel na v?stupní obrázek     unsigned8 *mskPtr = (unsigned8 *) gStuff->maskData;     //ukazatel na masku vstupního obrázku     Boolean maskPixel = false;        prah[0]=gKanal1;//nastavení jednotliv?ch prah?     prah[1]=gKanal2;     prah[2]=gKanal3;     prah[3]=gKanal4;     for (i=0; i < inRows; i++)     {         srcPtr = (unsigned8 *) gStuff->inData + (i * inColumns * inPlanes);//nastav na první pixel v ?ádku i         dstPtr = (unsigned8 *) gStuff->outData + (i * inColumns * inPlanes);//nastav na první pixel v ?ádku i         mskPtr = (unsigned8 *) gStuff->maskData + (i * inColumns);    //nastav na první pixel v ?ádku    i                     if (doProgress) UpdateProgress ((long) (gStuff->outRect.top + i) - gStuff->filterRect.top,(long) total);         for(j=0;j<inColumns;j++)         {                         maskPixel = (!mskPtr [0]); //na?tení masky             if (!maskPixel)     //pokud není maska uprav             {                 for (plane = 0; plane < inPlanes; plane++)                 {                 if(srcPtr[plane]>prah[plane]) srcPtr[plane]=255;                 else srcPtr[plane]=0;                 }             }             else //pokud je tak neupravuj             {                 for (plane = 0; plane < inPlanes; plane++) dstPtr [plane] = srcPtr [plane];                     }                                 srcPtr += inPlanes;//nastav na dal?í pixel v ?ádku i             dstPtr += inPlanes;//nastav na dal?í pixel v ?ádku i             mskPtr++; //nastav na dal?í pixel v ?ádku i         }                 } }/*****************************************************************************/ /* V?po?et a úpravy rozm?r? obrázku pro pot?eby UI */ void CalcGlobalProxies (GPtr globals) {    Rect    imageRect,imageRect1;     int16    selCenterH, selCenterV;     int16    selLength, selWidth;     int16    length, width;     int16    length2, width2;     length = (gOrigProxyRect.bottom - gOrigProxyRect.top); // zobrazovaná v??ka     length2 = length / 2;     width = (gOrigProxyRect.right - gOrigProxyRect.left); // zobrazovaná ?í?ka     width2 = width / 2;     selLength = gStuff->imageSize.v; // Vybraná v??ka     selWidth = gStuff->imageSize.h; // Vybraná ?í?ka     //Vycentrování preview     selCenterV = (selLength / 2);     selCenterH = (selWidth / 2);     imageRect.top = selCenterV - (length2);     imageRect.left = selCenterH - (width2);     imageRect.bottom = imageRect.top+length;     imageRect.right = imageRect.left+width;     imageRect1.top = 0;     imageRect1.left = 0;     imageRect1.bottom = gStuff->imageSize.v;     imageRect1.right = gStuff->imageSize.h; copyRect(&gProxyScaleRect, &imageRect);     copyRect(&gStuff->inRect, &imageRect1);     copyRect(&gStuff->outRect, &imageRect); }void SetupFilterRecordForProxy (GPtr globals, Rect proxyScaleRect, short scaleFactor) {    #ifdef __PIMWCW__         #pragma unused (proxyScaleRect)         #pragma unused (scaleFactor)     #endif     gStuff->inLoPlane = gStuff->outLoPlane = 0;     gStuff->inHiPlane = gStuff->outHiPlane = gStuff->planes - 1;     copyRect(&gStuff->maskRect, &gStuff->filterRect);     gStuff->inputRate = long2fixed(1L);     gStuff->maskRate = gStuff->inputRate;     gStuff->inputPadding = plugInWantsEdgeReplication;     gStuff->outputPadding = gStuff->inputPadding;     gStuff->maskPadding = gStuff->inputPadding;     gResult = AdvanceState (); }    void CalcProxyScaleFactor (Rect proxyScaleRect, Rect *proxyRect, short *scaleFactor) {    short filterHeight;     short filterWidth;     short itemHeight;     short itemWidth;     Point fraction;     shrinkRect (proxyRect, kGutter, kGutter);          // for the border     filterHeight = (proxyScaleRect.bottom - proxyScaleRect.top);     filterWidth = (proxyScaleRect.right - proxyScaleRect.left);     itemHeight = (proxyRect->bottom - proxyRect->top);     itemWidth = (proxyRect->right - proxyRect->left);     if (itemHeight > filterHeight) itemHeight = filterHeight;     if (itemWidth > filterWidth) itemWidth = filterWidth;     fraction.h = ((filterWidth + itemWidth) / itemWidth)-1;     fraction.v = ((filterHeight + itemHeight) / itemHeight)-1;     if (fraction.h > fraction.v) *scaleFactor = fraction.h;     else *scaleFactor = fraction.v;     copyRect (proxyRect, &proxyScaleRect);        scaleRect (proxyRect, 1, *scaleFactor); }/****************************************************************************/ /* Hlavní rutina Zoomování preview */ void DoZoomRect (GPtr globals,Boolean mask) {        if (gResult == userCanceledErr) return;             if (gRepFactor <= 1 && gRepFactor > 0)         ZoomOutRect (globals, mask);     else if (gRepFactor > 1)         ZoomInRect (globals, mask);         }/*****************************************************************************/ /* Zoom in. Zv?t?ení gRepFactor >= 1 */ /*****************************************************************************/ void ZoomInRect (GPtr globals, Boolean mask) {    short offsetOutColumns, offsetOutRows;     short centerInColumns, centerInRows;     short offsetInColumns, offsetInRows;     short difColumns, difRows;        short proxyCenterCol, proxyCenterRow;     short proxyOffsetCol, proxyOffsetRow;     int srcX,srcY ;     int i,j,ii,jj,max,polo,plane;     unsigned8 *dstPtr;     unsigned8 *mskPtr;     unsigned8 *mskPtr2;     const short outColumns= gStuff->outRect.right - gStuff->outRect.left;     const short outRows = gStuff->outRect.bottom - gStuff->outRect.top;        const short outPlanes = gStuff->outHiPlane - gStuff->outLoPlane + 1;     const short inColumns = gStuff->imageSize.h;     const short inRows = gStuff->imageSize.v;     const short inPlanes =gStuff->outHiPlane - gStuff->outLoPlane + 1;     double pomoc;        Boolean maskPixel = false;         offsetOutColumns = outColumns / 2;     offsetOutRows = outRows / 2;     centerInColumns = inColumns / 2;     centerInRows = inRows / 2;     offsetInColumns = (short)(inColumns * gRepFactor / 2);     offsetInRows = (short)(inRows * gRepFactor / 2);     difColumns        = offsetInColumns - offsetOutColumns;     difRows = offsetInRows - offsetOutRows; difColumns /= (short)gRepFactor;     difRows /=(short)gRepFactor;     gPozice.x=gSPozice.x+(short)gDif.x;     if (gPozice.x> difColumns) gPozice.x=difColumns;     if (gPozice.x<-difColumns) gPozice.x=-difColumns;     gPozice.y=gSPozice.y+(short)gDif.y;     if (gPozice.y> difRows) gPozice.y=difRows;     if (gPozice.y<-difRows) gPozice.y=-difRows;     proxyCenterCol = gOrigProxyRect.left + ((gOrigProxyRect.right - gOrigProxyRect.left) / 4);     proxyCenterRow = gOrigProxyRect.top + ((gOrigProxyRect.bottom - gOrigProxyRect.top) / 4);     proxyOffsetCol = outColumns / 2;     proxyOffsetRow = outRows / 2;         max=(int)sqrt((inRows/2)*(inRows/2)+(inColumns/2)*(inColumns/2));     for (i = 0; i < outRows; i ++)     {         i--;         for(ii = 1;ii<=gRepFactor;ii++)         {             i++;             if(i==outRows) break;             mskPtr2= (unsigned8 *)gSHOWmask + (i * outColumns);             dstPtr = (unsigned8 *)gStuff->outData + (i * outColumns * outPlanes);                     mskPtr = (unsigned8 *)gFFTmask + (- gPozice.x + difColumns + (((int)(i/gRepFactor) + difRows - gPozice.y ) * inColumns));             srcX= - gPozice.x + difColumns + (((int)(i/gRepFactor) + difRows - gPozice.y ) * inColumns);             srcY=srcX-((short)(srcX/inColumns))*inColumns;                     for (j = 0; j < outColumns; j ++)             {                 j--;                 for (jj = 1;jj<=gRepFactor;jj++)                 {                     if (gIMaska) mskPtr2[0] = 255-mskPtr[0];                     else mskPtr2[0]=255;                                     if(!mask)                     {                         if (mskPtr[0]) for(plane=0;plane<inPlanes;plane++)  dstPtr[plane]=((gInten*gFFTdata[((srcX/inColumns)*inColumns+srcY)*inPlanes+plane]/100)+(100-gInten)*gFFTdata2[((srcX/inColumns)*inColumns+srcY)*inPlanes+plane]/100);                                                                      else         for(plane=0;plane<inPlanes;plane++) dstPtr[plane]=gFFTdata[((srcX/inColumns)*inColumns+srcY)*inPlanes+plane];                     }                     mskPtr2++;                     dstPtr +=outPlanes;                     j++;                     if (j==outColumns) break;                 }                 srcY ++;                 mskPtr++;             }         }     }         gProxyRect.left = proxyCenterCol - proxyOffsetCol > gOrigProxyRect.left                     ? proxyCenterCol - proxyOffsetCol : gOrigProxyRect.left;     gProxyRect.right = proxyCenterCol + proxyOffsetCol < gOrigProxyRect.right                     ? proxyCenterCol + proxyOffsetCol : gOrigProxyRect.right;     gProxyRect.top = proxyCenterRow - proxyOffsetRow > gOrigProxyRect.top                     ? proxyCenterRow - proxyOffsetRow : gOrigProxyRect.top;     gProxyRect.bottom = proxyCenterRow + proxyOffsetRow < gOrigProxyRect.bottom                     ? proxyCenterRow + proxyOffsetRow : gOrigProxyRect.bottom; }    /*****************************************************************************/ /* Zoom Out. Zmen?ení gRepFactor between 0...1. */ void ZoomOutRect (GPtr globals,    Boolean mask) {    const unsigned8 kUIBackcolor = 191;     short offsetOutColumns, offsetOutRows;     short startOutColumns, startOutRows, endOutColumns, endOutRows;     const short outColumns= gStuff->outRect.right - gStuff->outRect.left;     const short outRows = gStuff->outRect.bottom - gStuff->outRect.top;        const short outPlanes = gStuff->outHiPlane - gStuff->outLoPlane + 1;     const short inColumns = gStuff->imageSize.h;     const short inRows = gStuff->imageSize.v;     const short inPlanes = gStuff->inHiPlane - gStuff->inLoPlane + 1;     short centerInColumns, centerInRows;     short offsetInColumns, offsetInRows;     short difColumns, difRows; short offset = 0;     short proxyCenterCol, proxyCenterRow;     short proxyOffsetCol, proxyOffsetRow;     float HFactor = 0; float VFactor = 0;     double pomoc;     unsigned8 *dstPtr;     unsigned8 *mskPtr;     unsigned8 *mskPtr2;     int i,j,srcX,srcY,max,polo,plane;     Boolean maskPixel = false;         offsetOutColumns = outColumns / 2;     offsetOutRows = outRows / 2;     startOutColumns = 0;     startOutRows = 0;     endOutColumns = outColumns-1;     endOutRows = outRows-1;     centerInColumns = inColumns / 2;     centerInRows = inRows / 2;     offsetInColumns = (short)(inColumns * gRepFactor / 2);     offsetInRows = (short)(inRows * gRepFactor / 2);     difColumns        = offsetInColumns - offsetOutColumns;     difRows = offsetInRows - offsetOutRows;         if (difColumns<0)     {         difColumns++;         startOutColumns-=difColumns;         difColumns--;         endOutColumns+=difColumns;         difColumns=0;     }     if (difRows<0)     {         difRows++;         startOutRows-=difRows;         difRows--;         endOutRows+=difRows;         difRows=0;     }     gPozice.x=gSPozice.x+(short)gDif.x;     if (gPozice.x> difColumns) gPozice.x=difColumns;     if (gPozice.x<-difColumns) gPozice.x=-difColumns;     gPozice.y=gSPozice.y+(short)gDif.y;     if (gPozice.y> difRows) gPozice.y=difRows;     if (gPozice.y<-difRows) gPozice.y=-difRows;     proxyCenterCol = gOrigProxyRect.left + ((gOrigProxyRect.right - gOrigProxyRect.left) / 2);     proxyCenterRow = gOrigProxyRect.top + ((gOrigProxyRect.bottom - gOrigProxyRect.top) / 2);     proxyOffsetCol = (short)((outColumns * gRepFactor) / 2);     proxyOffsetRow = (short)((outRows * gRepFactor) / 2);     if (!mask)     {         for (i = 0;i < startOutRows;i ++)         {             dstPtr = (unsigned8 *) gStuff->outData + (i * outColumns* outPlanes);             mskPtr2= (unsigned8 *) gSHOWmask + (i * outColumns);             for (j = 0; j < outColumns; j ++)         {             for(plane=0;plane<inPlanes;plane++) dstPtr [plane] = kUIBackcolor;             mskPtr2[0]=255;             dstPtr +=outPlanes;             mskPtr2++;             }         }     }     max=(int)sqrt((inRows/2)*(inRows/2)+(inColumns/2)*(inColumns/2));     for (i = startOutRows;i < endOutRows; i ++)     {         srcX = (short)((-gPozice.x+difColumns)/gRepFactor) + ((i - startOutRows + (short)((-gPozice.y+difRows)/gRepFactor) + offset) * inColumns );         dstPtr = (unsigned8 *) gStuff->outData + (i * outColumns* outPlanes);     mskPtr2= (unsigned8 *) gSHOWmask + (i * outColumns);         mskPtr = (unsigned8 *) gFFTmask + (short)((-gPozice.x+difColumns)/gRepFactor) + ((i - startOutRows + (short)((-gPozice.y + difRows)/gRepFactor) + offset) * inColumns);         HFactor=0;         for (j = 0; j < startOutColumns;j ++)         {             for(plane=0;plane<inPlanes;plane++) dstPtr [plane] = kUIBackcolor;             mskPtr2[0]=255;             dstPtr += outPlanes;             mskPtr2++;         }         srcY=srcX-((short)(srcX/inColumns))*inColumns;                 for (j = startOutColumns;j < endOutColumns; j ++)         {                         if (gIMaska) mskPtr2[0] = 255-mskPtr[0];             else mskPtr2[0]=255;                     if(!mask)             {                 if(mskPtr[0]) for(plane=0;plane<inPlanes;plane++) dstPtr[plane]=((gInten*gFFTdata[((srcX/inColumns)*inColumns+srcY)*inPlanes+plane]/100)+(100-gInten)*gFFTdata2[((srcX/inColumns)*inColumns+srcY)*inPlanes+plane]/100);                                                              else         for(plane=0;plane<inPlanes;plane++) dstPtr[plane]=gFFTdata[((srcX/inColumns)*inColumns+srcY)*inPlanes+plane];                             }             dstPtr +=outPlanes;             srcY ++;             mskPtr++;             mskPtr2++;             HFactor += ((1/gRepFactor)-1);             while(HFactor>=0.5) {                HFactor-=1;                 srcY ++;                 mskPtr++; }        }         if(!mask)         {             for (j = endOutColumns; j < outColumns; j ++)             {                 for(plane=0;plane<inPlanes;plane++) dstPtr [plane] = kUIBackcolor;                 mskPtr2[0]=255;                             dstPtr += outPlanes;                 mskPtr2++;             }         }         VFactor += ((1/gRepFactor)-1);         while(VFactor>=0.5)         {             VFactor-=1;             offset+=1;         }     }     if(!mask)     {         for (i = endOutRows; i < outRows; i ++)         {             dstPtr = (unsigned8 *) gStuff->outData + (i * outColumns* outPlanes);             mskPtr2= (unsigned8 *) gSHOWmask + (i * outColumns);             for (j = 0; j < outColumns; j ++)             {                 for(plane=0;plane<inPlanes;plane++) dstPtr [plane] = kUIBackcolor;                    mskPtr2[0]=255;                 dstPtr += outPlanes;                 mskPtr2++;             }         }     }     gProxyRect.left = proxyCenterCol - proxyOffsetCol > gOrigProxyRect.left                     ? proxyCenterCol - proxyOffsetCol : gOrigProxyRect.left;     gProxyRect.right = proxyCenterCol + proxyOffsetCol < gOrigProxyRect.right                     ? proxyCenterCol + proxyOffsetCol : gOrigProxyRect.right;     gProxyRect.top = proxyCenterRow - proxyOffsetRow > gOrigProxyRect.top                     ? proxyCenterRow - proxyOffsetRow : gOrigProxyRect.top;     gProxyRect.bottom = proxyCenterRow + proxyOffsetRow < gOrigProxyRect.bottom; }    /*****************************************************************************/ /* Zooms in by one factor (parts of 1.0 until 1.0, then 1.0, 2.0, etc. */ void ZoomIn (short *zoom) {    if (*zoom >= kNumZooms)         *zoom += kNumZooms;     else (*zoom)++; }void ZoomOut (short *zoom) {    if (*zoom >= (kNumZooms*2))         *zoom -= kNumZooms;     else (*zoom)--; }/*****************************************************************************/ /* Takes an enumeration and returns corresponding zoom size */ short GetZoomFactor (GPtr globals) {    short    sub = 0;     short    returnValue = noErr;         /* check for zoomFactor bounds */         if (gZoomFactor <= kMinZoom)     {         gZoomFactor = kMinZoom;         returnValue = hitLowBounds;     }     else if (gZoomFactor >= kMaxZoom)     {         gZoomFactor = kMaxZoom;         returnValue = hitHighBounds;     }         sub = gZoomFactor % kNumZooms;         switch (sub)         {             case 1:                 gRepFactor = (float)0.25;                 break;             case 2:                 gRepFactor = (float)0.33;                 break;             case 3:                 gRepFactor = (float)0.50;                 break;             case 4:                 gRepFactor = (float)0.66;                 break;             case 5:                 gRepFactor = (float)0.80;                 break;             default:                 gRepFactor = (float)0;                 break;         }         gRepFactor += gZoomFactor / kNumZooms;     return returnValue; }void scaleRect(Rect *l, short n, short d) {     l->left = (l->left * n) / d;     l->top = (l->top * n) / d;     l->right = (l->right * n) / d;     l->bottom = (l->bottom * n) / d; }void shrinkRect(Rect *l, short x, short y) {     l->left += x;     l->top += y;     l->right -= x;     l->bottom -= y; }void copyRect(Rect *l, const Rect *r) {     l->left = r->left;     l->top = r->top;     l->right = r->right;     l->bottom = r->bottom; }/******************************************************************************/ /* NEPOU?ITO - Pokud se filtruje po ?ástech */ void StartNoAdvanceState (GPtr globals) {    DoInitialRect(globals); }/*****************************************************************************/ /* NEPOU?ITO - inicializace první filtrované ?ásti - filtrování po ?ástech */ void DoInitialRect (GPtr globals) {    int32 total;     total = gStuff->filterRect.bottom - gStuff->filterRect.top;     gStuff->inLoPlane = gStuff->outLoPlane = 0;     gStuff->inHiPlane = gStuff->outHiPlane = gStuff->planes - 1;         /* Pou?ítí Alfa kanál? */     #if useAlpha     if (!gStuff->isFloating)     {         gStuff->wantsAbsolute = true;         if (gStuff->inLayerPlanes !=0 && gStuff->inTransparencyMask != 0)             gStuff->inHiPlane = gStuff->absLayerPlanes - 1 +                                 gStuff->absTransparencyMask +                                 gStuff->absLayerMasks +                                 gStuff->absInvertedLayerMasks +                                 gStuff->absNonLayerPlanes;                 if (gStuff->outLayerPlanes !=0 && gStuff->outTransparencyMask !=0)             gStuff->outHiPlane = gStuff->outLayerPlanes - 1 +                                 gStuff->outTransparencyMask +                                 gStuff->outLayerMasks +                                 gStuff->outInvertedLayerMasks +                                 gStuff->outNonLayerPlanes;     }     #endif     gStuff->inputRate = long2fixed (1L);     gStuff->maskRate = long2fixed (1L);     gStuff->maskPadding = gStuff->outputPadding = gStuff->inputPadding = 255;     gStuff->inRect = gStuff->outRect = gStuff->maskRect = gStuff->filterRect;     gStuff->inRect.bottom = gStuff->outRect.bottom = gStuff->maskRect.bottom = gStuff->inRect.top + gRowSkip; }/*****************************************************************************/ /* NEPOU?ITO - Dotaz na dal?í ?ást */ Boolean DoNextRect (GPtr globals) {    gStuff->inRect.top += gRowSkip; // next batch     gStuff->inRect.bottom += gRowSkip; // next batch     gStuff->outRect = gStuff->maskRect = gStuff->inRect;         return gStuff->inRect.top < gStuff->filterRect.bottom; }